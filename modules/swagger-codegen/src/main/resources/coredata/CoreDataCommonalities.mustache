// CoreDataCommonalities.swift
// API Version {{appVersion}}
// Generated: {{generatedDate}}
//

import Foundation
import CoreData

// MARK - Conform to Protocols From Swagger
{{#models}}{{#model}}{{#isBuildCoreData}}extension {{classname}}CD: Findable{{#isProtocolUUIDType}}, UUIDType{{/isProtocolUUIDType}}{{#isProtocolSortOrderType}}, SortOrderType{{/isProtocolSortOrderType}}{{#isProtocolNameType}}, NameType{{/isProtocolNameType}}{{#isProtocolSoftDeletableType}}, SoftDeletableType{{/isProtocolSoftDeletableType}} {}
{{/isBuildCoreData}}{{/model}}{{/models}}

protocol EntityNameable: class {
    static var entityName: String { get }
}

extension EntityNameable {
    static var entityName: String {
        return self.baseClassName
    }

    static var baseClassName: String! {
        let namespacedClassName = NSStringFromClass(self) as NSString
        let baseClassName = namespacedClassName.components(separatedBy: ".").last
        return baseClassName!
    }
}

// Findable Protocol - All Core Data Items are Findable
protocol Findable: class, EntityNameable { }

extension Findable {
    static var allObjects: [Self] {
        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: self.entityName)
        do {
            let results = try CDStack.context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
}

// SortOrderType Protocol - If the object has a sort_order
protocol SortOrderType: class, Findable {
    var sort_order: Int? { get set } // always setting integers to max in Core Data
}

extension SortOrderType {
    static func sortedObjects(ascending: Bool) -> [Self] {
        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: self.entityName)
        do {
            let sortDesc = NSSortDescriptor(key: "sort_order", ascending: ascending)
            fetch.sortDescriptors = [sortDesc]
            let results = try CDStack.context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
}

// MARK: - Find items by UUID

protocol UUIDType: class, EntityNameable {
     var uuid: String! { get }
     static func object(forUUID uuid: String, context: NSManagedObjectContext) -> NSManagedObject?
     static func objects(forUuids uuids: [String], context: NSManagedObjectContext) -> [NSManagedObject]?
     static var entityName: String { get }
}

extension NSManagedObject: EntityNameable {
    static var entityName: String { return self.baseClassName }
    
    static func object(forUUID uuid: String, context: NSManagedObjectContext) -> NSManagedObject? {
        let predUuid = NSPredicate(format: "uuid = %@", uuid)
        let request = NSFetchRequest<NSFetchRequestResult>(entityName:self.baseClassName)
        request.predicate = predUuid;
        
        do {
            let results = try context.fetch(request)
            assert(results.count <= 1, "Never should have more than one uuid!")
            if let object = results.first as? NSManagedObject {
                return object
            }
        } catch (let error) {
            assertionFailure("\(error)")
        }
        return nil
    }

    static func objects(forUuids uuids: [String], context: NSManagedObjectContext) -> [NSManagedObject]? {
        let objects = uuids.map{ object(forUUID: $0, context: context) }.flatMap{ $0 }
        if objects.count > 0 {
            return objects
        } else {
            return nil
        }
    }
}

// MARK: - Search by String in Object Name

protocol NameType: class, EntityNameable {
    var name: String? { get set }
}

extension NameType {
    
    static func objectsWithNameThatContainsString(aString: String) -> [Self] {
        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: self.entityName)
        fetch.predicate = NSPredicate(format: "name CONTAINS[cd] %@", aString)
        fetch.sortDescriptors = [NSSortDescriptor(key: "name", ascending: true)]
        do {
            let results = try CDStack.context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
    
    static func sortedObjectsByName(ascending: Bool) -> [Self] {
        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: self.entityName)
        do {
            let sortDesc = NSSortDescriptor(key: "name", ascending: ascending)
            fetch.sortDescriptors = [sortDesc]
            let results = try CDStack.context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }

}

// MARK: - Find soft deleted items.

protocol SoftDeletableType: class, EntityNameable {
    var deleted_on_server: Bool? { get set }
}

extension SoftDeletableType where Self: AnyObject
{
    static func softDeletedObjects(context: NSManagedObjectContext) -> [Self] {
        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: self.entityName
        )
        do {
            fetch.predicate = NSPredicate(format: "deleted_on_server == %@", NSNumber(value: true))
            let results = try context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
}