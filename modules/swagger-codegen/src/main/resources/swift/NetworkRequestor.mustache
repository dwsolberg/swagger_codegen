//
//  NetworkRequestor.swift
//

import Foundation

enum NetworkError: ErrorType {
    case InvalidCode(Int, AnyObject?)
    case MissingData
    case MissingJSON(String?)
    case NonHTTPResponse
}

public class NetworkRequestorWithResultType<T>
{
    let headers: [String:String]
    let parameters: [String:AnyObject]?
    let method: String
    let url: NSURL
    
    required public init(method: String, URL: NSURL, headers: [String:String], parameters: [String:AnyObject]?) {
        self.method = method
        self.url = URL
        self.headers = headers
        self.parameters = parameters
    }
    
    /// All calls return on the the main queue
	func sendWithResult(success: T? -> (), failure: ErrorType -> ()) -> Bool {
        guard let request = generateRequest() else { return false }
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.URLCache = NSURLCache.sharedURLCache()
        let session = NSURLSession(configuration: configuration)
        
        session.dataTaskWithRequest(request) { (data: NSData?, response: NSURLResponse?, error: NSError?) -> Void in
            
            // Handle Apple Error Cases
            if let error = error{
                assertionFailure("We got an error \(error)")
				delay(error, closure: failure)
                return
            }
            
            // Make sure it's an http response (it should be if we got to this point, but we have to check)
            guard let httpResponse = response as? NSHTTPURLResponse else {
                assertionFailure("We were expecting an http response, but instead got: \(response)")
				delay(NetworkError.NonHTTPResponse, closure: failure)
                return
            }
            
            // Handle Invalid Status Codes along with error response
            guard httpResponse.isValid else {
                assertionFailure("We got an invalid response code \(httpResponse.statusCode)")
                let errorInfo: AnyObject?
                if let data = data {
                    if let json = try? NSJSONSerialization.JSONObjectWithData(data, options: [NSJSONReadingOptions.AllowFragments]) {
                        errorInfo = json
                    } else {
                        errorInfo = NSString(data: data, encoding: NSUTF8StringEncoding)
                    }
                } else {
                    errorInfo = nil
                }
                let httpError = NetworkError.InvalidCode(httpResponse.statusCode, errorInfo)
				delay(httpError, closure: failure)
                return
            }
            
            // Success when no response is expected -- type is <Void>
            if () is T {
				delay(nil, closure: success)
                return   
            }
            
            // Handle any missing data - we should have data at this point
            guard let data = data else {
                let error = NetworkError.MissingData
				delay(error, closure: failure)
                return
            }

            // Handle invalid JSON
            guard let json: AnyObject = try? NSJSONSerialization.JSONObjectWithData(data, options: [NSJSONReadingOptions.AllowFragments])
                else {
                    let string = NSString(data: data, encoding: NSUTF8StringEncoding)
                    let error = NetworkError.MissingJSON(string as String?)
					delay(error, closure: failure)
                    return
            }
            
            // Return the decoded object
			let decodedJSON: T = Decoders.decode(json)
			delay(decodedJSON, closure: success)
            
        }.resume()
        
        return true
    }

    static func handleData(data: NSData?, success: (T?) -> (), failure: (ErrorType) -> ()){

		if () is T {
			success(nil)
			return
		}

		else if let tData =  data as? T {
			success(tData)
		}

		// Handle any missing data - we should have data at this point
		guard let data = data else {
			failure(NetworkError.MissingData)
			return
		}

		// Handle invalid JSON
		guard let json: AnyObject = try? NSJSONSerialization.JSONObjectWithData(data, options: [NSJSONReadingOptions.AllowFragments]) else {
				let string = NSString(data: data, encoding: NSUTF8StringEncoding)
				failure(NetworkError.MissingJSON(string as String?))
				return
		}

		// Return the decoded object
		let decodedJSON: T = Decoders.decode(json)
		success(decodedJSON)
	}

    private func generateRequest() -> NSURLRequest?
    {
		let cachePolicy: NSURLRequestCachePolicy = (Reachability.isConnectedToNetwork()) ? .ReturnCacheDataElseLoad : .ReturnCacheDataDontLoad

        let request : NSMutableURLRequest = NSMutableURLRequest(URL: url, cachePolicy: cachePolicy, timeoutInterval: 120)
        request.HTTPMethod = method
        if self.headers.count > 0 { request.allHTTPHeaderFields = headers }
        if let parameters = self.parameters where parameters.count > 0 {
            let encoded = parameters.encodeToJSON()
            let bodyData: NSData
            do {
                bodyData = try NSJSONSerialization.dataWithJSONObject(encoded, options: [])
            } catch {
                assertionFailure("Could not create data out of parameters \(parameters)")
                return nil
            }
            request.HTTPBody = bodyData
        }
        return request
    }

}