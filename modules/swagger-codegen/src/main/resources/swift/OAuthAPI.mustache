//
//  AuthAPI.swift
//  Created by David Solberg on 12/18/15.
//  Generated by Swagger
//

import Foundation

class AuthAPI {
    
    static let oauthURLString = "http://dev.myibucketlist.com/oauth/token"
    static let url = NSURL(string: oauthURLString)!
    
    /// Creates and securely saves a token if one exists from the account. Check the result for success to determine whether a token was granted.
    static func authorizeAccount(account: Account, completion: (result: NetworkResult<Oauth_info>) -> Void) {
        
        let parameters =
        [
            "grant_type":Network.OAuth.grant_type_password,
            "username":account.email,
            "password":account.password,
            "client_id":Network.OAuth.client_id,
            "client_secret":Network.OAuth.client_secret
        ]
        
        NetworkRequestorWithResultType<Oauth_info>.init(method: "POST", URL: url, headers: Network.Header.json, parameters: parameters).sendWithResult { (result: NetworkResult<Oauth_info>) -> Void in
            processResult(result, completion: completion)
        }
    }
    

    /// Refreshes the existing token if there is one. If no token exists, returns false. Also check the completion block to see whether the refresh was successful.
    static func refreshToken(completion: (result: NetworkResult<Oauth_info>) -> Void) -> Bool {

        guard let refreshtoken = Token.refresh else { return false }
        
        let parameters =
        [
            "grant_type":Network.OAuth.grant_type_refresh,
            "refresh_token":refreshtoken
        ]
        
        NetworkRequestorWithResultType<Oauth_info>.init(method: "POST", URL: url, headers: Network.Header.json, parameters: parameters).sendWithResult { (result: NetworkResult<Oauth_info>) -> Void in
                processResult(result, completion: completion)
        }
        return true
    }
    
    // MARK: - Helpers
    static func processResult(result: NetworkResult<Oauth_info>, completion: (result: NetworkResult<Oauth_info>) -> Void) {
        // Store the token if found
        if case NetworkResult.Success(let info) = result {
            if let accessToken = info?.access_token {
                Token.header = accessToken
            }
            if let refreshToken = info?.refresh_token {
                Token.refresh = refreshToken
            }
        }
        completion(result: result)
    }
}